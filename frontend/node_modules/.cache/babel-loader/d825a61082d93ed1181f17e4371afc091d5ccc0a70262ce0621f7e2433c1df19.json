{"ast":null,"code":"import _objectSpread from\"/Users/razashaikh/Desktop/sih/python-app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useReducer,useEffect}from'react';import{blockchainAPI}from'../services/api';// Initial state\nimport{jsx as _jsx}from\"react/jsx-runtime\";const initialState={isConnected:false,account:null,networkInfo:null,userProjects:[],carbonBalance:0,loading:false,error:null,contractAddresses:{},hasMetaMask:false};// Actions\nconst BLOCKCHAIN_ACTIONS={SET_LOADING:'SET_LOADING',SET_CONNECTED:'SET_CONNECTED',SET_ACCOUNT:'SET_ACCOUNT',SET_NETWORK_INFO:'SET_NETWORK_INFO',SET_USER_PROJECTS:'SET_USER_PROJECTS',SET_CARBON_BALANCE:'SET_CARBON_BALANCE',SET_ERROR:'SET_ERROR',SET_CONTRACT_ADDRESSES:'SET_CONTRACT_ADDRESSES',SET_HAS_METAMASK:'SET_HAS_METAMASK',RESET:'RESET'};// Reducer\nconst blockchainReducer=(state,action)=>{switch(action.type){case BLOCKCHAIN_ACTIONS.SET_LOADING:return _objectSpread(_objectSpread({},state),{},{loading:action.payload});case BLOCKCHAIN_ACTIONS.SET_CONNECTED:return _objectSpread(_objectSpread({},state),{},{isConnected:action.payload});case BLOCKCHAIN_ACTIONS.SET_ACCOUNT:return _objectSpread(_objectSpread({},state),{},{account:action.payload});case BLOCKCHAIN_ACTIONS.SET_NETWORK_INFO:return _objectSpread(_objectSpread({},state),{},{networkInfo:action.payload});case BLOCKCHAIN_ACTIONS.SET_USER_PROJECTS:return _objectSpread(_objectSpread({},state),{},{userProjects:action.payload});case BLOCKCHAIN_ACTIONS.SET_CARBON_BALANCE:return _objectSpread(_objectSpread({},state),{},{carbonBalance:action.payload});case BLOCKCHAIN_ACTIONS.SET_ERROR:return _objectSpread(_objectSpread({},state),{},{error:action.payload});case BLOCKCHAIN_ACTIONS.SET_CONTRACT_ADDRESSES:return _objectSpread(_objectSpread({},state),{},{contractAddresses:action.payload});case BLOCKCHAIN_ACTIONS.SET_HAS_METAMASK:return _objectSpread(_objectSpread({},state),{},{hasMetaMask:action.payload});case BLOCKCHAIN_ACTIONS.RESET:return _objectSpread(_objectSpread({},initialState),{},{hasMetaMask:state.hasMetaMask});default:return state;}};// Create context\nconst BlockchainContext=/*#__PURE__*/createContext();// Provider component\nexport const BlockchainProvider=_ref=>{let{children}=_ref;const[state,dispatch]=useReducer(blockchainReducer,initialState);// Initialize blockchain connection\nconst initializeBlockchain=async()=>{try{dispatch({type:BLOCKCHAIN_ACTIONS.SET_LOADING,payload:true});dispatch({type:BLOCKCHAIN_ACTIONS.SET_ERROR,payload:null});// Check if MetaMask is available\nconst hasMetaMask=blockchainAPI.hasMetaMask();dispatch({type:BLOCKCHAIN_ACTIONS.SET_HAS_METAMASK,payload:hasMetaMask});if(!hasMetaMask){throw new Error('MetaMask not detected. Please install MetaMask to use blockchain features.');}// Initialize blockchain connection\nconst success=await blockchainAPI.init();if(success){dispatch({type:BLOCKCHAIN_ACTIONS.SET_CONNECTED,payload:true});// Get account\nconst account=blockchainAPI.getAccount();dispatch({type:BLOCKCHAIN_ACTIONS.SET_ACCOUNT,payload:account});// Get network info\nconst networkInfo=await blockchainAPI.getNetworkInfo();dispatch({type:BLOCKCHAIN_ACTIONS.SET_NETWORK_INFO,payload:networkInfo});// Get contract addresses\nconst contractAddresses=blockchainAPI.getContractAddresses();dispatch({type:BLOCKCHAIN_ACTIONS.SET_CONTRACT_ADDRESSES,payload:contractAddresses});// Load user data\nawait loadUserData();console.log('🎉 Blockchain initialized successfully!');}else{throw new Error('Failed to connect to blockchain');}}catch(error){console.error('❌ Blockchain initialization failed:',error);dispatch({type:BLOCKCHAIN_ACTIONS.SET_ERROR,payload:error.message});dispatch({type:BLOCKCHAIN_ACTIONS.SET_CONNECTED,payload:false});}finally{dispatch({type:BLOCKCHAIN_ACTIONS.SET_LOADING,payload:false});}};// Load user-specific data\nconst loadUserData=async()=>{try{if(!blockchainAPI.isConnected())return;// Get user's projects from blockchain\nconst userProjects=await blockchainAPI.getUserProjects();dispatch({type:BLOCKCHAIN_ACTIONS.SET_USER_PROJECTS,payload:userProjects});// Get carbon credit balance\nconst carbonBalance=await blockchainAPI.getCarbonBalance();dispatch({type:BLOCKCHAIN_ACTIONS.SET_CARBON_BALANCE,payload:carbonBalance});}catch(error){console.error('Failed to load user data:',error);}};// Refresh user data\nconst refreshUserData=async()=>{await loadUserData();};// Disconnect blockchain\nconst disconnect=()=>{dispatch({type:BLOCKCHAIN_ACTIONS.RESET});console.log('🔌 Blockchain disconnected');};// Listen for account changes\nuseEffect(()=>{if(typeof window.ethereum!=='undefined'){const handleAccountsChanged=accounts=>{if(accounts.length===0){disconnect();}else if(accounts[0]!==state.account){dispatch({type:BLOCKCHAIN_ACTIONS.SET_ACCOUNT,payload:accounts[0]});loadUserData();}};const handleChainChanged=chainId=>{console.log('🔗 Chain changed:',chainId);// Reload the page or reconnect\nwindow.location.reload();};window.ethereum.on('accountsChanged',handleAccountsChanged);window.ethereum.on('chainChanged',handleChainChanged);return()=>{window.ethereum.removeListener('accountsChanged',handleAccountsChanged);window.ethereum.removeListener('chainChanged',handleChainChanged);};}},[state.account]);// Listen for blockchain events\nuseEffect(()=>{const handleBlockchainEvent=event=>{const{type,data}=event.detail;console.log('📡 Received blockchain event:',type,data);// Refresh user data when relevant events occur\nif(type==='ProjectRegistered'||type==='ProjectApproved'){loadUserData();}};window.addEventListener('blockchain-event',handleBlockchainEvent);return()=>{window.removeEventListener('blockchain-event',handleBlockchainEvent);};},[]);// Context value\nconst value=_objectSpread(_objectSpread({},state),{},{// Actions\ninitializeBlockchain,disconnect,refreshUserData,// Utilities\nformatAddress:blockchainAPI.formatAddress,// Helper functions\nisReady:state.isConnected&&!state.loading,needsMetaMask:!state.hasMetaMask,canConnect:state.hasMetaMask&&!state.isConnected&&!state.loading});return/*#__PURE__*/_jsx(BlockchainContext.Provider,{value:value,children:children});};// Hook to use blockchain context\nexport const useBlockchain=()=>{const context=useContext(BlockchainContext);if(!context){throw new Error('useBlockchain must be used within a BlockchainProvider');}return context;};export default BlockchainContext;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _objectSpread from \"/Users/razashaikh/Desktop/sih/python-app/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _wrapRegExp from \"/Users/razashaikh/Desktop/sih/python-app/frontend/node_modules/@babel/runtime/helpers/esm/wrapRegExp.js\";\nimport { bytesRegex, execTyped, integerRegex, isTupleRegex } from \"./chunk-WP7KDV47.mjs\";\nimport { __publicField } from \"./chunk-NHABU752.mjs\";\n\n// package.json\nvar name = \"abitype\";\nvar version = \"0.7.1\";\n\n// src/errors.ts\nvar BaseError = class extends Error {\n  constructor(shortMessage) {\n    var _args$cause;\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const details = args.cause instanceof BaseError ? args.cause.details : (_args$cause = args.cause) !== null && _args$cause !== void 0 && _args$cause.message ? args.cause.message : args.details;\n    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;\n    const message = [shortMessage || \"An error occurred.\", \"\", ...(args.metaMessages ? [...args.metaMessages, \"\"] : []), ...(docsPath ? [\"Docs: https://abitype.dev\".concat(docsPath)] : []), ...(details ? [\"Details: \".concat(details)] : []), \"Version: \".concat(name, \"@\").concat(version)].join(\"\\n\");\n    super(message);\n    __publicField(this, \"details\");\n    __publicField(this, \"docsPath\");\n    __publicField(this, \"metaMessages\");\n    __publicField(this, \"shortMessage\");\n    __publicField(this, \"name\", \"AbiTypeError\");\n    if (args.cause) this.cause = args.cause;\n    this.details = details;\n    this.docsPath = docsPath;\n    this.metaMessages = args.metaMessages;\n    this.shortMessage = shortMessage;\n  }\n};\n\n// src/narrow.ts\nfunction narrow(value) {\n  return value;\n}\n\n// src/human-readable/runtime/signatures.ts\nvar errorSignatureRegex = /*#__PURE__*/_wrapRegExp(/^error ([a-zA-Z0-9_]+)\\((.*?)\\)$/, {\n  name: 1,\n  parameters: 2\n});\nfunction isErrorSignature(signature) {\n  return errorSignatureRegex.test(signature);\n}\nfunction execErrorSignature(signature) {\n  return execTyped(errorSignatureRegex, signature);\n}\nvar eventSignatureRegex = /*#__PURE__*/_wrapRegExp(/^event ([a-zA-Z0-9_]+)\\((.*?)\\)$/, {\n  name: 1,\n  parameters: 2\n});\nfunction isEventSignature(signature) {\n  return eventSignatureRegex.test(signature);\n}\nfunction execEventSignature(signature) {\n  return execTyped(eventSignatureRegex, signature);\n}\nvar functionSignatureRegex = /*#__PURE__*/_wrapRegExp(/^function ([a-zA-Z0-9_]+)\\((.*?)\\)(?: (external|public{1}))?(?: (pure|view|nonpayable|payable{1}))?(?: returns \\((.*?)\\))?$/, {\n  name: 1,\n  parameters: 2,\n  scope: 3,\n  stateMutability: 4,\n  returns: 5\n});\nfunction isFunctionSignature(signature) {\n  return functionSignatureRegex.test(signature);\n}\nfunction execFunctionSignature(signature) {\n  return execTyped(functionSignatureRegex, signature);\n}\nvar structSignatureRegex = /*#__PURE__*/_wrapRegExp(/^struct ([a-zA-Z0-9_]+) \\{(.*?)\\}$/, {\n  name: 1,\n  properties: 2\n});\nfunction isStructSignature(signature) {\n  return structSignatureRegex.test(signature);\n}\nfunction execStructSignature(signature) {\n  return execTyped(structSignatureRegex, signature);\n}\nvar constructorSignatureRegex = /*#__PURE__*/_wrapRegExp(/^constructor\\((.*?)\\)(?:\\s(payable{1}))?$/, {\n  parameters: 1,\n  stateMutability: 2\n});\nfunction isConstructorSignature(signature) {\n  return constructorSignatureRegex.test(signature);\n}\nfunction execConstructorSignature(signature) {\n  return execTyped(constructorSignatureRegex, signature);\n}\nvar fallbackSignatureRegex = /^fallback\\(\\)$/;\nfunction isFallbackSignature(signature) {\n  return fallbackSignatureRegex.test(signature);\n}\nvar receiveSignatureRegex = /^receive\\(\\) external payable$/;\nfunction isReceiveSignature(signature) {\n  return receiveSignatureRegex.test(signature);\n}\nvar modifiers = /* @__PURE__ */new Set([\"memory\", \"indexed\", \"storage\", \"calldata\"]);\nvar eventModifiers = /* @__PURE__ */new Set([\"indexed\"]);\nvar functionModifiers = /* @__PURE__ */new Set([\"calldata\", \"memory\", \"storage\"]);\n\n// src/human-readable/runtime/cache.ts\nfunction getParameterCacheKey(param, type) {\n  if (type) return \"\".concat(type, \":\").concat(param);\n  return param;\n}\nvar parameterCache = /* @__PURE__ */new Map([\n// Unnamed\n[\"address\", {\n  type: \"address\"\n}], [\"bool\", {\n  type: \"bool\"\n}], [\"bytes\", {\n  type: \"bytes\"\n}], [\"bytes32\", {\n  type: \"bytes32\"\n}], [\"int\", {\n  type: \"int256\"\n}], [\"int256\", {\n  type: \"int256\"\n}], [\"string\", {\n  type: \"string\"\n}], [\"uint\", {\n  type: \"uint256\"\n}], [\"uint8\", {\n  type: \"uint8\"\n}], [\"uint16\", {\n  type: \"uint16\"\n}], [\"uint24\", {\n  type: \"uint24\"\n}], [\"uint32\", {\n  type: \"uint32\"\n}], [\"uint64\", {\n  type: \"uint64\"\n}], [\"uint96\", {\n  type: \"uint96\"\n}], [\"uint112\", {\n  type: \"uint112\"\n}], [\"uint160\", {\n  type: \"uint160\"\n}], [\"uint192\", {\n  type: \"uint192\"\n}], [\"uint256\", {\n  type: \"uint256\"\n}],\n// Named\n[\"address owner\", {\n  type: \"address\",\n  name: \"owner\"\n}], [\"address to\", {\n  type: \"address\",\n  name: \"to\"\n}], [\"bool approved\", {\n  type: \"bool\",\n  name: \"approved\"\n}], [\"bytes _data\", {\n  type: \"bytes\",\n  name: \"_data\"\n}], [\"bytes data\", {\n  type: \"bytes\",\n  name: \"data\"\n}], [\"bytes signature\", {\n  type: \"bytes\",\n  name: \"signature\"\n}], [\"bytes32 hash\", {\n  type: \"bytes32\",\n  name: \"hash\"\n}], [\"bytes32 r\", {\n  type: \"bytes32\",\n  name: \"r\"\n}], [\"bytes32 root\", {\n  type: \"bytes32\",\n  name: \"root\"\n}], [\"bytes32 s\", {\n  type: \"bytes32\",\n  name: \"s\"\n}], [\"string name\", {\n  type: \"string\",\n  name: \"name\"\n}], [\"string symbol\", {\n  type: \"string\",\n  name: \"symbol\"\n}], [\"string tokenURI\", {\n  type: \"string\",\n  name: \"tokenURI\"\n}], [\"uint tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\"\n}], [\"uint8 v\", {\n  type: \"uint8\",\n  name: \"v\"\n}], [\"uint256 balance\", {\n  type: \"uint256\",\n  name: \"balance\"\n}], [\"uint256 tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\"\n}], [\"uint256 value\", {\n  type: \"uint256\",\n  name: \"value\"\n}],\n// Indexed\n[\"event:address indexed from\", {\n  type: \"address\",\n  name: \"from\",\n  indexed: true\n}], [\"event:address indexed to\", {\n  type: \"address\",\n  name: \"to\",\n  indexed: true\n}], [\"event:uint indexed tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\",\n  indexed: true\n}], [\"event:uint256 indexed tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\",\n  indexed: true\n}]]);\n\n// src/human-readable/runtime/utils.ts\nfunction parseSignature(signature) {\n  let structs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (isFunctionSignature(signature)) {\n    var _match$stateMutabilit;\n    const match = execFunctionSignature(signature);\n    if (!match) throw new BaseError(\"Invalid function signature.\", {\n      details: signature\n    });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(parseAbiParameter(inputParams[i], {\n        modifiers: functionModifiers,\n        structs,\n        type: \"function\"\n      }));\n    }\n    const outputs = [];\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns);\n      const outputLength = outputParams.length;\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(parseAbiParameter(outputParams[i], {\n          modifiers: functionModifiers,\n          structs,\n          type: \"function\"\n        }));\n      }\n    }\n    return {\n      name: match.name,\n      type: \"function\",\n      stateMutability: (_match$stateMutabilit = match.stateMutability) !== null && _match$stateMutabilit !== void 0 ? _match$stateMutabilit : \"nonpayable\",\n      inputs,\n      outputs\n    };\n  }\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature);\n    if (!match) throw new BaseError(\"Invalid event signature.\", {\n      details: signature\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        modifiers: eventModifiers,\n        structs,\n        type: \"event\"\n      }));\n    }\n    return {\n      name: match.name,\n      type: \"event\",\n      inputs: abiParameters\n    };\n  }\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature);\n    if (!match) throw new BaseError(\"Invalid error signature.\", {\n      details: signature\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        structs,\n        type: \"error\"\n      }));\n    }\n    return {\n      name: match.name,\n      type: \"error\",\n      inputs: abiParameters\n    };\n  }\n  if (isConstructorSignature(signature)) {\n    var _match$stateMutabilit2;\n    const match = execConstructorSignature(signature);\n    if (!match) throw new BaseError(\"Invalid constructor signature.\", {\n      details: signature\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        structs,\n        type: \"constructor\"\n      }));\n    }\n    return {\n      type: \"constructor\",\n      stateMutability: (_match$stateMutabilit2 = match.stateMutability) !== null && _match$stateMutabilit2 !== void 0 ? _match$stateMutabilit2 : \"nonpayable\",\n      inputs: abiParameters\n    };\n  }\n  if (isFallbackSignature(signature)) return {\n    type: \"fallback\"\n  };\n  if (isReceiveSignature(signature)) return {\n    type: \"receive\",\n    stateMutability: \"payable\"\n  };\n  throw new BaseError(\"Unknown signature.\", {\n    details: signature\n  });\n}\nvar abiParameterWithoutTupleRegex = /*#__PURE__*/_wrapRegExp(/^([a-zA-Z0-9_]+?)((?:\\[\\d*?\\])+?)?(?:\\s(calldata|indexed|memory|storage{1}))?(?:\\s([a-zA-Z0-9_]+))?$/, {\n  type: 1,\n  array: 2,\n  modifier: 3,\n  name: 4\n});\nvar abiParameterWithTupleRegex = /*#__PURE__*/_wrapRegExp(/^\\((.+?)\\)((?:\\[\\d*?\\])+?)?(?:\\s(calldata|indexed|memory|storage{1}))?(?:\\s([a-zA-Z0-9_]+))?$/, {\n  type: 1,\n  array: 2,\n  modifier: 3,\n  name: 4\n});\nvar dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n  var _options$structs, _match$array;\n  const parameterCacheKey = getParameterCacheKey(param, options === null || options === void 0 ? void 0 : options.type);\n  if (parameterCache.has(parameterCacheKey)) return parameterCache.get(parameterCacheKey);\n  const isTuple = isTupleRegex.test(param);\n  const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n  if (!match) throw new BaseError(\"Invalid ABI parameter.\", {\n    details: param\n  });\n  if (match.name && isSolidityKeyword(match.name)) throw new BaseError(\"Invalid ABI parameter.\", {\n    details: param,\n    metaMessages: [\"\\\"\".concat(match.name, \"\\\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html\")]\n  });\n  const name2 = match.name ? {\n    name: match.name\n  } : {};\n  const indexed = match.modifier === \"indexed\" ? {\n    indexed: true\n  } : {};\n  const structs = (_options$structs = options === null || options === void 0 ? void 0 : options.structs) !== null && _options$structs !== void 0 ? _options$structs : {};\n  let type;\n  let components = {};\n  if (isTuple) {\n    type = \"tuple\";\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      components_.push(parseAbiParameter(params[i], {\n        structs\n      }));\n    }\n    components = {\n      components: components_\n    };\n  } else if (match.type in structs) {\n    type = \"tuple\";\n    components = {\n      components: structs[match.type]\n    };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = \"\".concat(match.type, \"256\");\n  } else {\n    type = match.type;\n    if (!((options === null || options === void 0 ? void 0 : options.type) === \"struct\") && !isSolidityType(type)) throw new BaseError(\"Unknown type.\", {\n      metaMessages: [\"Type \\\"\".concat(type, \"\\\" is not a valid ABI type.\")]\n    });\n  }\n  if (match.modifier) {\n    var _options$modifiers, _options$modifiers$ha;\n    if (!(options !== null && options !== void 0 && (_options$modifiers = options.modifiers) !== null && _options$modifiers !== void 0 && (_options$modifiers$ha = _options$modifiers.has) !== null && _options$modifiers$ha !== void 0 && _options$modifiers$ha.call(_options$modifiers, match.modifier))) throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [\"Modifier \\\"\".concat(match.modifier, \"\\\" not allowed\").concat(options !== null && options !== void 0 && options.type ? \" in \\\"\".concat(options.type, \"\\\" type\") : \"\", \".\")]\n    });\n    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [\"Modifier \\\"\".concat(match.modifier, \"\\\" not allowed\").concat(options !== null && options !== void 0 && options.type ? \" in \\\"\".concat(options.type, \"\\\" type\") : \"\", \".\"), \"Data location can only be specified for array, struct, or mapping types, but \\\"\".concat(match.modifier, \"\\\" was given.\")]\n    });\n  }\n  const abiParameter = _objectSpread(_objectSpread(_objectSpread({\n    type: \"\".concat(type).concat((_match$array = match.array) !== null && _match$array !== void 0 ? _match$array : \"\")\n  }, name2), indexed), components);\n  parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\nfunction splitParameters(params) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let current = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (params === \"\") {\n    if (current === \"\") return result;\n    if (depth !== 0) throw new BaseError(\"Unbalanced parentheses.\", {\n      metaMessages: [\"\\\"\".concat(current.trim(), \"\\\" has too many \").concat(depth > 0 ? \"opening\" : \"closing\", \" parentheses.\")],\n      details: \"Depth \\\"\".concat(depth, \"\\\"\")\n    });\n    return [...result, current.trim()];\n  }\n  const length = params.length;\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n    switch (char) {\n      case \",\":\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, \"\".concat(current).concat(char), depth);\n      case \"(\":\n        return splitParameters(tail, result, \"\".concat(current).concat(char), depth + 1);\n      case \")\":\n        return splitParameters(tail, result, \"\".concat(current).concat(char), depth - 1);\n      default:\n        return splitParameters(tail, result, \"\".concat(current).concat(char), depth);\n    }\n  }\n  return [];\n}\nfunction isSolidityType(type) {\n  return type === \"address\" || type === \"bool\" || type === \"function\" || type === \"string\" || bytesRegex.test(type) || integerRegex.test(type);\n}\nvar protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name2) {\n  return name2 === \"address\" || name2 === \"bool\" || name2 === \"function\" || name2 === \"string\" || name2 === \"tuple\" || bytesRegex.test(name2) || integerRegex.test(name2) || protectedKeywordsRegex.test(name2);\n}\nfunction isValidDataLocation(type, isArray) {\n  return isArray || type === \"bytes\" || type === \"string\" || type === \"tuple\";\n}\n\n// src/human-readable/runtime/structs.ts\nfunction parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature)) continue;\n    const match = execStructSignature(signature);\n    if (!match) throw new BaseError(\"Invalid struct signature.\", {\n      details: signature\n    });\n    const properties = match.properties.split(\";\");\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed) continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: \"struct\"\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length) throw new BaseError(\"Invalid struct signature.\", {\n      details: signature,\n      metaMessages: [\"No properties exist.\"]\n    });\n    shallowStructs[match.name] = components;\n  }\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name2, parameters] = entries[i];\n    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nvar typeWithoutTupleRegex = /*#__PURE__*/_wrapRegExp(/^([a-zA-Z0-9_]+?)((?:\\[\\d*?\\])+?)?$/, {\n  type: 1,\n  array: 2\n});\nfunction resolveStructs(abiParameters, structs) {\n  let ancestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : /* @__PURE__ */new Set();\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple) components.push(abiParameter);else {\n      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n      if (!(match !== null && match !== void 0 && match.type)) throw new BaseError(\"Invalid ABI parameter.\", {\n        details: JSON.stringify(abiParameter, null, 2),\n        metaMessages: [\"ABI parameter type is invalid.\"]\n      });\n      const {\n        array,\n        type\n      } = match;\n      if (type in structs) {\n        var _structs$type;\n        if (ancestors.has(type)) throw new BaseError(\"Circular reference detected.\", {\n          metaMessages: [\"Struct \\\"\".concat(type, \"\\\" is a circular reference.\")]\n        });\n        components.push(_objectSpread(_objectSpread({}, abiParameter), {}, {\n          type: \"tuple\".concat(array !== null && array !== void 0 ? array : \"\"),\n          components: resolveStructs((_structs$type = structs[type]) !== null && _structs$type !== void 0 ? _structs$type : [], structs, /* @__PURE__ */new Set([...ancestors, type]))\n        }));\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter);else throw new BaseError(\"Unknown type.\", {\n          metaMessages: [\"Type \\\"\".concat(type, \"\\\" is not a valid ABI type. Perhaps you forgot to include a struct signature?\")]\n        });\n      }\n    }\n  }\n  return components;\n}\n\n// src/human-readable/parseAbi.ts\nfunction parseAbi(signatures) {\n  const structs = parseStructs(signatures);\n  const abi = [];\n  const length = signatures.length;\n  for (let i = 0; i < length; i++) {\n    const signature = signatures[i];\n    if (isStructSignature(signature)) continue;\n    abi.push(parseSignature(signature, structs));\n  }\n  return abi;\n}\n\n// src/human-readable/parseAbiItem.ts\nfunction parseAbiItem(signature) {\n  let abiItem;\n  if (typeof signature === \"string\") abiItem = parseSignature(signature);else {\n    const structs = parseStructs(signature);\n    const length = signature.length;\n    for (let i = 0; i < length; i++) {\n      const signature_ = signature[i];\n      if (isStructSignature(signature_)) continue;\n      abiItem = parseSignature(signature_, structs);\n      break;\n    }\n  }\n  if (!abiItem) throw new BaseError(\"Failed to parse ABI item.\", {\n    details: \"parseAbiItem(\".concat(JSON.stringify(signature, null, 2), \")\"),\n    docsPath: \"/api/human.html#parseabiitem-1\"\n  });\n  return abiItem;\n}\n\n// src/human-readable/parseAbiParameter.ts\nfunction parseAbiParameter2(param) {\n  let abiParameter;\n  if (typeof param === \"string\") abiParameter = parseAbiParameter(param, {\n    modifiers\n  });else {\n    const structs = parseStructs(param);\n    const length = param.length;\n    for (let i = 0; i < length; i++) {\n      const signature = param[i];\n      if (isStructSignature(signature)) continue;\n      abiParameter = parseAbiParameter(signature, {\n        modifiers,\n        structs\n      });\n      break;\n    }\n  }\n  if (!abiParameter) throw new BaseError(\"Failed to parse ABI parameter.\", {\n    details: \"parseAbiParameter(\".concat(JSON.stringify(param, null, 2), \")\"),\n    docsPath: \"/api/human.html#parseabiparameter-1\"\n  });\n  return abiParameter;\n}\n\n// src/human-readable/parseAbiParameters.ts\nfunction parseAbiParameters(params) {\n  const abiParameters = [];\n  if (typeof params === \"string\") {\n    const parameters = splitParameters(params);\n    const length = parameters.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(parameters[i], {\n        modifiers\n      }));\n    }\n  } else {\n    const structs = parseStructs(params);\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if (isStructSignature(signature)) continue;\n      const parameters = splitParameters(signature);\n      const length2 = parameters.length;\n      for (let k = 0; k < length2; k++) {\n        abiParameters.push(parseAbiParameter(parameters[k], {\n          modifiers,\n          structs\n        }));\n      }\n    }\n  }\n  if (abiParameters.length === 0) throw new BaseError(\"Failed to parse ABI parameters.\", {\n    details: \"parseAbiParameters(\".concat(JSON.stringify(params, null, 2), \")\"),\n    docsPath: \"/api/human.html#parseabiparameters-1\"\n  });\n  return abiParameters;\n}\nexport { BaseError, narrow, parseAbi, parseAbiItem, parseAbiParameter2 as parseAbiParameter, parseAbiParameters };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}